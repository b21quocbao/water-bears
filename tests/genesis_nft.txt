use scrypto::prelude::*;
use scrypto_unit::*;
use transaction::builder::ManifestBuilder;

#[derive(ScryptoSbor, NonFungibleData, ManifestEncode)]
pub struct WaterBear {
    pub name: String,

    #[mutable]
    pub key_image_url: Url,

    #[mutable]
    pub background: String,
    #[mutable]
    pub base: String,
    #[mutable]
    pub mouth: String,
    #[mutable]
    pub hats: String,
    #[mutable]
    pub neck: String,
    #[mutable]
    pub eyes: String,
    #[mutable]
    pub clothes: String,
}

#[test]
fn test() {
    // Setup the environment
    let mut test_runner = TestRunnerBuilder::new()
        .with_custom_genesis(CustomGenesis::default(
            Epoch::of(1),
            CustomGenesis::default_consensus_manager_config(),
        ))
        .without_trace()
        .build();

    // Create an account
    let (public_key, _private_key, account_component) = test_runner.new_allocated_account();

    // Publish package
    let package_address = test_runner.compile_and_publish(this_package!());

    // Test the `instantiate_meme_nft` function.
    let manifest = ManifestBuilder::new()
        .call_function(
            package_address,
            "MemeNft",
            "instantiate_meme_nft",
            manifest_args!(),
        )
        .deposit_batch(account_component)
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();
    let owner_badge = receipt.expect_commit(true).new_resource_addresses()[0];
    let nft = receipt.expect_commit(true).new_resource_addresses()[1];
    let component = receipt.expect_commit(true).new_component_addresses()[0];

    // update_payment
    let manifest = ManifestBuilder::new()
        .create_proof_from_account_of_amount(account_component, owner_badge, dec!(1))
        .call_method(component, "update_payment", (XRD, dec!(250)))
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    // mint_nft
    let manifest = ManifestBuilder::new()
        .create_proof_from_account_of_amount(account_component, owner_badge, dec!(1))
        .call_method(
            component,
            "mint_nft",
            (
                dec!(1),
                "https://arweave.net/SJy8goVGtZFy8FOgS3h8-RlyZzIwk8RucGMQ7e3N04c",
                "Green",
                "Red",
                "",
                "",
                "",
                "",
                "",
            ),
        )
        .call_method(
            component,
            "mint_nft",
            (
                dec!(2),
                "https://arweave.net/SJy8goVGtZFy8FOgS3h8-RlyZzIwk8RucGMQ7e3N04c",
                "Green",
                "Red",
                "",
                "",
                "",
                "",
                "",
            ),
        )
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    // buy_nft
    let manifest = ManifestBuilder::new()
        .withdraw_from_account(account_component, XRD, dec!(500))
        .take_from_worktop(XRD, dec!(250), "nft_bucket_1")
        .call_method_with_name_lookup(component, "buy_nft", |lookup| {
            (lookup.bucket("nft_bucket_1"),)
        })
        .take_from_worktop(XRD, dec!(250), "nft_bucket_2")
        .call_method_with_name_lookup(component, "buy_nft", |lookup| {
            (lookup.bucket("nft_bucket_2"),)
        })
        .deposit_batch(account_component)
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    // withdraw_from_vault
    let manifest = ManifestBuilder::new()
        .create_proof_from_account_of_amount(account_component, owner_badge, dec!(1))
        .call_method(component, "withdraw_from_vault", (XRD,))
        .deposit_batch(account_component)
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    // Test the `instantiate_stake_pool` function.
    let manifest = ManifestBuilder::new()
        .call_function(
            package_address,
            "StakePool",
            "instantiate_stake_pool",
            manifest_args!(nft, owner_badge, XRD),
        )
        .deposit_batch(account_component)
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();
    let stake_pool_component = receipt.expect_commit(true).new_component_addresses()[0];
    let id_resource = receipt.expect_commit(true).new_resource_addresses()[0];

    // deposit_reward_pool
    let manifest = ManifestBuilder::new()
        .withdraw_from_account(account_component, XRD, dec!(250))
        .take_all_from_worktop(XRD, "xrd_bucket")
        .call_method_with_name_lookup(stake_pool_component, "deposit_reward_pool", |lookup| {
            (lookup.bucket("xrd_bucket"),)
        })
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    // create_id
    let manifest = ManifestBuilder::new()
        .call_method(stake_pool_component, "create_id", ())
        .deposit_batch(account_component)
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    // stake nft
    let manifest = ManifestBuilder::new()
        .create_proof_from_account_of_non_fungibles(
            account_component,
            id_resource,
            indexset!(NonFungibleLocalId::integer(1)),
        )
        .pop_from_auth_zone("proof_1")
        .withdraw_non_fungible_from_account(
            account_component,
            NonFungibleGlobalId::new(
                nft,
                NonFungibleLocalId::String(StringNonFungibleLocalId::new("WaterBear_1").unwrap()),
            ),
        )
        .take_all_from_worktop(nft, "nft_bucket_1")
        .call_method_with_name_lookup(stake_pool_component, "stake", |lookup| {
            (lookup.bucket("nft_bucket_1"), lookup.proof("proof_1"))
        })
        .create_proof_from_account_of_non_fungibles(
            account_component,
            id_resource,
            indexset!(NonFungibleLocalId::integer(1)),
        )
        .pop_from_auth_zone("proof_2")
        .withdraw_non_fungible_from_account(
            account_component,
            NonFungibleGlobalId::new(
                nft,
                NonFungibleLocalId::String(StringNonFungibleLocalId::new("WaterBear_2").unwrap()),
            ),
        )
        .take_all_from_worktop(nft, "nft_bucket_2")
        .call_method_with_name_lookup(stake_pool_component, "stake", |lookup| {
            (lookup.bucket("nft_bucket_2"), lookup.proof("proof_2"))
        })
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    let date_ms =
        test_runner.get_current_proposer_timestamp_ms() + 3 * 24 * 3600 * 1000 + 12 * 3600 * 1000;
    let receipt = test_runner.advance_to_round_at_timestamp(Round::of(1), date_ms);
    receipt.expect_commit_success();

    // update_reward_factor
    let manifest = ManifestBuilder::new()
        .create_proof_from_account_of_amount(account_component, owner_badge, dec!(1))
        .call_method(stake_pool_component, "update_reward_factor", (dec!(4.9),))
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    // claim_rewards
    let manifest = ManifestBuilder::new()
        .create_proof_from_account_of_non_fungibles(
            account_component,
            id_resource,
            indexset!(NonFungibleLocalId::integer(1)),
        )
        .pop_from_auth_zone("proof")
        .call_method_with_name_lookup(stake_pool_component, "claim_rewards", |lookup| {
            (lookup.proof("proof"),)
        })
        .deposit_batch(account_component)
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    // withdraw
    let manifest = ManifestBuilder::new()
        .create_proof_from_account_of_non_fungibles(
            account_component,
            id_resource,
            indexset!(NonFungibleLocalId::integer(1)),
        )
        .pop_from_auth_zone("proof_1")
        .call_method_with_name_lookup(stake_pool_component, "withdraw", |lookup| {
            (
                NonFungibleLocalId::String(StringNonFungibleLocalId::new("WaterBear_1").unwrap()),
                lookup.proof("proof_1"),
            )
        })
        .create_proof_from_account_of_non_fungibles(
            account_component,
            id_resource,
            indexset!(NonFungibleLocalId::integer(1)),
        )
        .pop_from_auth_zone("proof_2")
        .call_method_with_name_lookup(stake_pool_component, "withdraw", |lookup| {
            (
                NonFungibleLocalId::String(StringNonFungibleLocalId::new("WaterBear_2").unwrap()),
                lookup.proof("proof_2"),
            )
        })
        .deposit_batch(account_component)
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    let date_ms =
        test_runner.get_current_proposer_timestamp_ms() + 10 * 24 * 3600 * 1000 + 12 * 3600 * 1000;
    let receipt = test_runner.advance_to_round_at_timestamp(Round::of(1), date_ms);
    receipt.expect_commit_success();

    // claim_rewards
    let manifest = ManifestBuilder::new()
        .create_proof_from_account_of_non_fungibles(
            account_component,
            id_resource,
            indexset!(NonFungibleLocalId::integer(1)),
        )
        .pop_from_auth_zone("proof")
        .call_method_with_name_lookup(stake_pool_component, "claim_rewards", |lookup| {
            (lookup.proof("proof"),)
        })
        .deposit_batch(account_component)
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();

    // withdraw_reward_pool
    let manifest = ManifestBuilder::new()
        .create_proof_from_account_of_amount(account_component, owner_badge, dec!(1))
        .call_method(stake_pool_component, "withdraw_reward_pool", (dec!(230),))
        .deposit_batch(account_component)
        .build();
    let receipt = test_runner.execute_manifest_ignoring_fee(
        manifest,
        vec![NonFungibleGlobalId::from_public_key(&public_key)],
    );
    receipt.expect_commit_success();
}
